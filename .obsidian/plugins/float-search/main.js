/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/floatSearchIndex.ts
var floatSearchIndex_exports = {};
__export(floatSearchIndex_exports, {
  default: () => FloatSearchPlugin
});
module.exports = __toCommonJS(floatSearchIndex_exports);
var import_obsidian2 = require("obsidian");

// src/leafView.ts
var import_obsidian = require("obsidian");
var popovers = /* @__PURE__ */ new WeakMap();
function isEmebeddedLeaf(leaf) {
  return leaf.containerEl.matches(".fs-block.fs-leaf-view .workspace-leaf");
}
function genId(size) {
  const chars = [];
  for (let n = 0; n < size; n++)
    chars.push((16 * Math.random() | 0).toString(16));
  return chars.join("");
}
function nosuper(base) {
  const derived = function() {
    return Object.setPrototypeOf(new import_obsidian.Component(), new.target.prototype);
  };
  derived.prototype = base.prototype;
  return Object.setPrototypeOf(derived, base);
}
var spawnLeafView = (plugin, initiatingEl, leaf, onShowCallback) => {
  let parent = app.workspace.activeLeaf;
  if (!parent)
    parent = leaf;
  if (!initiatingEl)
    initiatingEl = parent == null ? void 0 : parent.containerEl;
  const hoverPopover = new EmbeddedView(parent, initiatingEl, plugin, void 0, onShowCallback);
  return [hoverPopover.attachLeaf(), hoverPopover];
};
var _a, _b, _c, _d;
var EmbeddedView = class extends nosuper(import_obsidian.HoverPopover) {
  constructor(parent, targetEl, plugin, waitTime, onShowCallback) {
    super();
    this.targetEl = targetEl;
    this.plugin = plugin;
    this.onShowCallback = onShowCallback;
    this.abortController = this.addChild(new import_obsidian.Component());
    this.detaching = false;
    this.opening = false;
    this.rootSplit = new import_obsidian.WorkspaceSplit(window.app.workspace, "vertical");
    this.isPinned = true;
    this.oldPopover = (_a = this.parent) == null ? void 0 : _a.hoverPopover;
    this.document = (_d = (_c = (_b = this.targetEl) == null ? void 0 : _b.ownerDocument) != null ? _c : window.activeDocument) != null ? _d : window.document;
    this.id = genId(8);
    this.hoverEl = this.document.defaultView.createDiv({
      cls: "fs-block fs-leaf-view",
      attr: { id: "fs-" + this.id }
    });
    if (waitTime === void 0) {
      waitTime = 300;
    }
    this.onTarget = true;
    this.parent = parent;
    this.waitTime = waitTime;
    this.state = import_obsidian.PopoverState.Showing;
    const { hoverEl } = this;
    this.abortController.load();
    this.show();
    this.onShow();
    this.setActive = this._setActive.bind(this);
    popovers.set(this.hoverEl, this);
    this.hoverEl.addClass("fs-block");
    this.containerEl = this.hoverEl.createDiv("fs-content");
    this.buildWindowControls();
    this.setInitialDimensions();
  }
  static activeWindows() {
    const windows = [window];
    const { floatingSplit } = app.workspace;
    if (floatingSplit) {
      for (const split of floatingSplit.children) {
        if (split.win)
          windows.push(split.win);
      }
    }
    return windows;
  }
  static containerForDocument(doc) {
    if (doc !== document && app.workspace.floatingSplit)
      for (const container of app.workspace.floatingSplit.children) {
        if (container.doc === doc)
          return container;
      }
    return app.workspace.rootSplit;
  }
  static activePopovers() {
    return this.activeWindows().flatMap(this.popoversForWindow);
  }
  static popoversForWindow(win) {
    var _a2, _b2;
    return Array.prototype.slice.call((_b2 = (_a2 = win == null ? void 0 : win.document) == null ? void 0 : _a2.body.querySelectorAll(".fs-leaf-view")) != null ? _b2 : []).map((el) => popovers.get(el)).filter((he) => he);
  }
  static forLeaf(leaf) {
    const el = leaf && document.body.matchParent.call(leaf.containerEl, ".fs-leaf-view");
    return el ? popovers.get(el) : void 0;
  }
  static iteratePopoverLeaves(ws, cb) {
    for (const popover of this.activePopovers()) {
      if (popover.rootSplit && ws.iterateLeaves(cb, popover.rootSplit))
        return true;
    }
    return false;
  }
  _setActive(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    this.plugin.app.workspace.setActiveLeaf(this.leaves()[0], { focus: true });
  }
  getDefaultMode() {
    return "source";
  }
  updateLeaves() {
    if (this.onTarget && this.targetEl && !this.document.contains(this.targetEl)) {
      this.onTarget = false;
      this.transition();
    }
    let leafCount = 0;
    this.plugin.app.workspace.iterateLeaves((leaf) => {
      leafCount++;
    }, this.rootSplit);
    if (leafCount === 0) {
      this.hide();
    }
    this.hoverEl.setAttribute("data-leaf-count", leafCount.toString());
  }
  leaves() {
    const leaves = [];
    this.plugin.app.workspace.iterateLeaves((leaf) => {
      leaves.push(leaf);
    }, this.rootSplit);
    return leaves;
  }
  setInitialDimensions() {
    this.hoverEl.style.height = "auto";
    this.hoverEl.style.width = "100%";
  }
  transition() {
    if (this.shouldShow()) {
      if (this.state === import_obsidian.PopoverState.Hiding) {
        this.state = import_obsidian.PopoverState.Shown;
        clearTimeout(this.timer);
      }
    } else {
      if (this.state === import_obsidian.PopoverState.Showing) {
        this.hide();
      } else {
        if (this.state === import_obsidian.PopoverState.Shown) {
          this.state = import_obsidian.PopoverState.Hiding;
          this.timer = window.setTimeout(() => {
            if (this.shouldShow()) {
              this.transition();
            } else {
              this.hide();
            }
          }, this.waitTime);
        }
      }
    }
  }
  buildWindowControls() {
    this.titleEl = this.document.defaultView.createDiv("popover-titlebar");
    this.titleEl.createDiv("popover-title");
    this.containerEl.prepend(this.titleEl);
  }
  attachLeaf() {
    this.rootSplit.getRoot = () => this.plugin.app.workspace[this.document === document ? "rootSplit" : "floatingSplit"];
    this.rootSplit.getContainer = () => EmbeddedView.containerForDocument(this.document);
    this.titleEl.insertAdjacentElement("afterend", this.rootSplit.containerEl);
    const leaf = this.plugin.app.workspace.createLeafInParent(this.rootSplit, 0);
    this.updateLeaves();
    return leaf;
  }
  onload() {
    super.onload();
    this.registerEvent(this.plugin.app.workspace.on("layout-change", this.updateLeaves, this));
    this.registerEvent(app.workspace.on("layout-change", () => {
      this.rootSplit.children.forEach((item, index) => {
        if (item instanceof import_obsidian.WorkspaceTabs) {
          this.rootSplit.replaceChild(index, item.children[0]);
        }
      });
    }));
  }
  onShow() {
    var _a2, _b2;
    const closeDelay = 600;
    setTimeout(() => this.waitTime = closeDelay, closeDelay);
    (_a2 = this.oldPopover) == null ? void 0 : _a2.hide();
    this.oldPopover = null;
    this.hoverEl.toggleClass("is-new", true);
    this.document.body.addEventListener("click", () => {
      this.hoverEl.toggleClass("is-new", false);
    }, { once: true, capture: true });
    if (this.parent) {
      this.parent.hoverPopover = this;
    }
    const viewHeaderEl = this.hoverEl.querySelector(".view-header");
    viewHeaderEl == null ? void 0 : viewHeaderEl.remove();
    const sizer = this.hoverEl.querySelector(".workspace-leaf");
    if (sizer)
      this.hoverEl.appendChild(sizer);
    const inlineTitle = this.hoverEl.querySelector(".inline-title");
    if (inlineTitle)
      inlineTitle.remove();
    (_b2 = this.onShowCallback) == null ? void 0 : _b2.call(this);
    this.onShowCallback = void 0;
  }
  detect(el) {
    const { targetEl } = this;
    if (targetEl) {
      this.onTarget = el === targetEl || targetEl.contains(el);
    }
  }
  shouldShow() {
    return this.shouldShowSelf() || this.shouldShowChild();
  }
  shouldShowChild() {
    return EmbeddedView.activePopovers().some((popover) => {
      if (popover !== this && popover.targetEl && this.hoverEl.contains(popover.targetEl)) {
        return popover.shouldShow();
      }
      return false;
    });
  }
  shouldShowSelf() {
    return !this.detaching && !!(this.onTarget || this.state == import_obsidian.PopoverState.Shown || this.document.querySelector(`body>.modal-container, body > #he${this.id} ~ .menu, body > #he${this.id} ~ .suggestion-container`));
  }
  show() {
    this.state = import_obsidian.PopoverState.Shown;
    this.timer = 0;
    this.targetEl.appendChild(this.hoverEl);
    this.onShow();
    app.workspace.onLayoutChange();
    this.load();
    if (this.hoverEl.dataset.imgHeight && this.hoverEl.dataset.imgWidth) {
      this.hoverEl.style.height = parseFloat(this.hoverEl.dataset.imgHeight) + this.titleEl.offsetHeight + "px";
      this.hoverEl.style.width = parseFloat(this.hoverEl.dataset.imgWidth) + "px";
    }
  }
  onHide() {
    var _a2;
    this.oldPopover = null;
    if (((_a2 = this.parent) == null ? void 0 : _a2.hoverPopover) === this) {
      this.parent.hoverPopover = null;
    }
  }
  hide() {
    var _a2;
    this.onTarget = false;
    this.detaching = true;
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = 0;
    }
    this.hoverEl.hide();
    if (this.opening)
      return;
    const leaves = this.leaves();
    if (leaves.length) {
      this.targetEl.empty();
    } else {
      this.parent = null;
      (_a2 = this.abortController) == null ? void 0 : _a2.unload();
      this.abortController = void 0;
      return this.nativeHide();
    }
  }
  nativeHide() {
    var _a2;
    const { hoverEl, targetEl } = this;
    this.state = import_obsidian.PopoverState.Hidden;
    hoverEl.detach();
    if (targetEl) {
      const parent = targetEl.matchParent(".fs-leaf-view");
      if (parent)
        (_a2 = popovers.get(parent)) == null ? void 0 : _a2.transition();
    }
    this.onHide();
    this.unload();
  }
  resolveLink(linkText, sourcePath) {
    const link = (0, import_obsidian.parseLinktext)(linkText);
    const tFile = link ? this.plugin.app.metadataCache.getFirstLinkpathDest(link.path, sourcePath) : null;
    return tFile;
  }
  async openLink(linkText, sourcePath, eState, createInLeaf) {
    var _a2, _b2, _c2;
    let file = this.resolveLink(linkText, sourcePath);
    const link = (0, import_obsidian.parseLinktext)(linkText);
    if (!file && createInLeaf) {
      const folder = this.plugin.app.fileManager.getNewFileParent(sourcePath);
      file = await this.plugin.app.fileManager.createNewMarkdownFile(folder, link.path);
    }
    if (!file) {
      return;
    }
    const { viewRegistry } = this.plugin.app;
    const viewType = viewRegistry.typeByExtension[file.extension];
    if (!viewType || !viewRegistry.viewByType[viewType]) {
      return;
    }
    eState = Object.assign(this.buildEphemeralState(file, link), eState);
    const parentMode = this.getDefaultMode();
    const state = this.buildState(parentMode, eState);
    const leaf = await this.openFile(file, state, createInLeaf);
    const leafViewType = (_a2 = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a2.getViewType();
    if (leafViewType === "image") {
      if (((_b2 = this.parent) == null ? void 0 : _b2.hasOwnProperty("editorEl")) && this.parent.editorEl.hasClass("is-live-preview")) {
        this.waitTime = 3e3;
      }
      const img = leaf.view.contentEl.querySelector("img");
      this.hoverEl.dataset.imgHeight = String(img.naturalHeight);
      this.hoverEl.dataset.imgWidth = String(img.naturalWidth);
      this.hoverEl.dataset.imgRatio = String(img.naturalWidth / img.naturalHeight);
    } else if (leafViewType === "pdf") {
      this.hoverEl.style.height = "800px";
      this.hoverEl.style.width = "600px";
    }
    if (((_c2 = state.state) == null ? void 0 : _c2.mode) === "source") {
      this.whenShown(() => {
        var _a3, _b3, _c3, _d2;
        if ((0, import_obsidian.requireApiVersion)("1.0"))
          (_c3 = (_b3 = (_a3 = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a3.editMode) == null ? void 0 : _b3.reinit) == null ? void 0 : _c3.call(_b3);
        (_d2 = leaf == null ? void 0 : leaf.view) == null ? void 0 : _d2.setEphemeralState(state.eState);
      });
    }
  }
  whenShown(callback) {
    if (this.detaching)
      return;
    const existingCallback = this.onShowCallback;
    this.onShowCallback = () => {
      if (this.detaching)
        return;
      callback();
      if (typeof existingCallback === "function")
        existingCallback();
    };
    if (this.state === import_obsidian.PopoverState.Shown) {
      this.onShowCallback();
      this.onShowCallback = void 0;
    }
  }
  async openFile(file, openState, useLeaf) {
    if (this.detaching)
      return;
    const leaf = useLeaf != null ? useLeaf : this.attachLeaf();
    this.opening = true;
    try {
      await leaf.openFile(file, openState);
    } catch (e) {
      console.error(e);
    } finally {
      this.opening = false;
      if (this.detaching)
        this.hide();
    }
    this.plugin.app.workspace.setActiveLeaf(leaf);
    return leaf;
  }
  buildState(parentMode, eState) {
    return {
      active: false,
      state: { mode: "source" },
      eState
    };
  }
  buildEphemeralState(file, link) {
    const cache = this.plugin.app.metadataCache.getFileCache(file);
    const subpath = cache ? (0, import_obsidian.resolveSubpath)(cache, (link == null ? void 0 : link.subpath) || "") : void 0;
    const eState = { subpath: link == null ? void 0 : link.subpath };
    if (subpath) {
      eState.line = subpath.start.line;
      eState.startLoc = subpath.start;
      eState.endLoc = subpath.end || void 0;
    }
    return eState;
  }
};

// node_modules/.pnpm/monkey-around@2.3.0/node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/floatSearchIndex.ts
var FloatSearchPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.applyDebounceTimer = 0;
  }
  applySettingsUpdate() {
    clearTimeout(this.applyDebounceTimer);
    this.applyDebounceTimer = window.setTimeout(() => {
      this.state = {
        ...this.state,
        query: ""
      };
    }, 3e4);
  }
  async onload() {
    this.patchWorkspace();
    this.patchWorkspaceLeaf();
    this.registerObsidianCommands();
    this.addRibbonIcon("search", "Search Obsidian In Modal", () => {
      this.modal = new FloatSearchModal((state) => {
        this.state = state;
        this.applySettingsUpdate();
      }, this.app, this, this.state);
      this.modal.open();
    });
  }
  onunload() {
    this.state = void 0;
  }
  patchWorkspace() {
    let layoutChanging = false;
    const uninstaller = around(import_obsidian2.Workspace.prototype, {
      getLeaf: (next) => function(...args) {
        const activeLeaf = this.activeLeaf;
        if (activeLeaf) {
          const fsCtnEl = activeLeaf.parent.containerEl.parentElement;
          if (fsCtnEl == null ? void 0 : fsCtnEl.classList.contains("fs-content")) {
            if (activeLeaf.view.getViewType() === "markdown") {
              return activeLeaf;
            }
            const newLeaf = app.workspace.getUnpinnedLeaf();
            if (newLeaf) {
              this.setActiveLeaf(newLeaf);
            }
          }
          return next.call(this, ...args);
        }
        return next.call(this, ...args);
      },
      changeLayout(old) {
        return async function(workspace) {
          layoutChanging = true;
          try {
            await old.call(this, workspace);
          } finally {
            layoutChanging = false;
          }
        };
      },
      iterateLeaves(old) {
        return function(arg1, arg2) {
          if (old.call(this, arg1, arg2))
            return true;
          const cb = typeof arg1 === "function" ? arg1 : arg2;
          const parent = typeof arg1 === "function" ? arg2 : arg1;
          if (!parent)
            return false;
          if (layoutChanging)
            return false;
          if (parent === app.workspace.rootSplit || import_obsidian2.WorkspaceContainer && parent instanceof import_obsidian2.WorkspaceContainer) {
            for (const popover of EmbeddedView.popoversForWindow(parent.win)) {
              if (old.call(this, cb, popover.rootSplit))
                return true;
            }
          }
          return false;
        };
      },
      onDragLeaf(old) {
        return function(event, leaf) {
          return old.call(this, event, leaf);
        };
      }
    });
    this.register(uninstaller);
  }
  patchWorkspaceLeaf() {
    this.register(around(import_obsidian2.WorkspaceLeaf.prototype, {
      getRoot(old) {
        return function() {
          const top = old.call(this);
          return (top == null ? void 0 : top.getRoot) === this.getRoot ? top : top == null ? void 0 : top.getRoot();
        };
      },
      setPinned(old) {
        return function(pinned) {
          old.call(this, pinned);
          if (isEmebeddedLeaf(this) && !pinned)
            this.setPinned(true);
        };
      },
      openFile(old) {
        return function(file, openState) {
          if (isEmebeddedLeaf(this)) {
            setTimeout(around(import_obsidian2.Workspace.prototype, {
              recordMostRecentOpenedFile(old2) {
                return function(_file) {
                  if (_file !== file) {
                    return old2.call(this, _file);
                  }
                };
              }
            }), 1);
            const recentFiles = this.app.plugins.plugins["recent-files-obsidian"];
            if (recentFiles) {
              setTimeout(around(recentFiles, {
                shouldAddFile(old2) {
                  return function(_file) {
                    return _file !== file && old2.call(this, _file);
                  };
                }
              }), 1);
            }
          }
          const view = old.call(this, file, openState);
          setTimeout(() => {
            const fsCtnEl = this.parent.containerEl.parentElement;
            if (!(fsCtnEl == null ? void 0 : fsCtnEl.classList.contains("fs-content")))
              return;
            if (file.extension != "canvas")
              return;
            const canvas = this.view.canvas;
            setTimeout(() => {
              var _a2, _b2;
              if (canvas && ((_a2 = openState == null ? void 0 : openState.eState) == null ? void 0 : _a2.match)) {
                let node = (_b2 = canvas.data.nodes) == null ? void 0 : _b2.find((e) => e.text === openState.eState.match.content);
                node = canvas.nodes.get(node.id);
                canvas.selectOnly(node);
                canvas.zoomToSelection();
              }
            }, 20);
          }, 1);
          return view;
        };
      }
    }));
  }
  registerObsidianCommands() {
    this.registerObsidianProtocolHandler("fs", (path) => {
      this.modal = new FloatSearchModal((state) => {
        this.state = state;
        this.applySettingsUpdate();
      }, this.app, this, { query: path.query, current: false });
      this.modal.open();
    });
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      if (!editor) {
        return;
      }
      if (editor.getSelection().length === 0) {
        return;
      }
      const selection = editor.getSelection();
      menu.addItem((item) => {
        item.setTitle('Search "' + selection + '"').setIcon("search").onClick(() => {
          this.modal = new FloatSearchModal((state) => {
            this.state = state;
            this.applySettingsUpdate();
          }, this.app, this, { query: selection, current: false });
          this.modal.open();
        });
      });
    }));
    this.addCommand({
      id: "search-obsidian-globally",
      name: "Search Obsidian Globally",
      callback: () => {
        this.modal = new FloatSearchModal((state) => {
          this.state = state;
        }, this.app, this, { ...this.state, query: "", current: false });
        this.modal.open();
      }
    });
    this.addCommand({
      id: "search-obsidian-globally-state",
      name: "Search Obsidian Globally (With Last State)",
      callback: () => {
        this.modal = new FloatSearchModal((state) => {
          this.state = state;
        }, this.app, this, { ...this.state, current: false });
        this.modal.open();
      }
    });
    this.addCommand({
      id: "search-in-current-file",
      name: "Search In Current File",
      callback: () => {
        const activeLeaf = this.app.workspace.activeLeaf;
        if (!activeLeaf)
          return;
        const viewType = activeLeaf.view.getViewType();
        if (viewType !== "markdown" && viewType !== "canvas") {
          new import_obsidian2.Notice("This command only works in markdown and canvas files.", 3e3);
          return;
        }
        const currentFile = activeLeaf.view.file;
        this.modal = new FloatSearchModal((state) => {
          this.state = state;
          this.applySettingsUpdate();
        }, this.app, this, { ...this.state, query: " path:" + currentFile.path, current: true });
        this.modal.open();
      }
    });
  }
};
var FloatSearchModal = class extends import_obsidian2.Modal {
  constructor(cb, app2, plugin, state) {
    super(app2);
    this.plugin = plugin;
    this.cb = cb;
    this.state = state;
  }
  async onOpen() {
    const { contentEl, containerEl, modalEl } = this;
    this.searchCtnEl = contentEl.createDiv({ cls: "float-search-modal-search-ctn" });
    this.instructionsEl = modalEl.createDiv({ cls: "float-search-modal-instructions" });
    this.initInstructions(this.instructionsEl);
    this.initCss(contentEl, modalEl, containerEl);
    await this.initSearchView(this.searchCtnEl);
    this.initInput();
    this.initContent();
  }
  onClose() {
    var _a2, _b2;
    const { contentEl } = this;
    this.cb(this.searchLeaf.view.getState());
    this.searchLeaf.detach();
    (_a2 = this.fileLeaf) == null ? void 0 : _a2.detach();
    this.searchEmbeddedView.unload();
    (_b2 = this.fileEmbeddedView) == null ? void 0 : _b2.unload();
    contentEl.empty();
  }
  initInstructions(instructionsEl) {
    const navigateInstructionsEl = instructionsEl.createDiv({ cls: "float-search-modal-instructions-navigate" });
    const collapseInstructionsEl = instructionsEl.createDiv({ cls: "float-search-modal-instructions-collapse" });
    const enterInstructionsEl = instructionsEl.createDiv({ cls: "float-search-modal-instructions-enter" });
    const altEnterInstructionsEl = instructionsEl.createDiv({ cls: "float-search-modal-instructions-alt-enter" });
    const tabInstructionsEl = instructionsEl.createDiv({ cls: "float-search-modal-instructions-tab" });
    const switchInstructionsEl = instructionsEl.createDiv({ cls: "float-search-modal-instructions-switch" });
    const navigateIconEl = navigateInstructionsEl.createSpan({ cls: "float-search-modal-instructions-key" });
    const navigateTextEl = navigateInstructionsEl.createSpan({ cls: "float-search-modal-instructions-text" });
    navigateIconEl.setText("\u2191\u2193");
    navigateTextEl.setText("Navigate");
    const collapseIconEl = collapseInstructionsEl.createSpan({ cls: "float-search-modal-instructions-key" });
    const collapseTextEl = collapseInstructionsEl.createSpan({ cls: "float-search-modal-instructions-text" });
    collapseIconEl.setText("Shift+\u2191\u2193");
    collapseTextEl.setText("Collapse/Expand");
    const enterIconEl = enterInstructionsEl.createSpan({ cls: "float-search-modal-instructions-key" });
    const enterTextEl = enterInstructionsEl.createSpan({ cls: "float-search-modal-instructions-text" });
    enterIconEl.setText("\u21B5");
    enterTextEl.setText("Open in background");
    const altEnterIconEl = altEnterInstructionsEl.createSpan({ cls: "float-search-modal-instructions-key" });
    const altEnterTextEl = altEnterInstructionsEl.createSpan({ cls: "float-search-modal-instructions-text" });
    altEnterIconEl.setText("Alt+\u21B5");
    altEnterTextEl.setText("Open File and Close");
    const tabIconEl = tabInstructionsEl.createSpan({ cls: "float-search-modal-instructions-key" });
    const tabTextEl = tabInstructionsEl.createSpan({ cls: "float-search-modal-instructions-text" });
    tabIconEl.setText("Tab/Shift+Tab");
    tabTextEl.setText("Preview/Close Preview");
    const switchIconEl = switchInstructionsEl.createSpan({ cls: "float-search-modal-instructions-key" });
    const switchTextEl = switchInstructionsEl.createSpan({ cls: "float-search-modal-instructions-text" });
    switchIconEl.setText("Ctrl+G");
    switchTextEl.setText("Switch Between Search and File View");
    const clickInstructionsEl = instructionsEl.createDiv({ cls: "float-search-modal-instructions-click" });
    const clickIconEl = clickInstructionsEl.createSpan({ cls: "float-search-modal-instructions-key" });
    const clickTextEl = clickInstructionsEl.createSpan({ cls: "float-search-modal-instructions-text" });
    clickIconEl.setText("Alt+Click");
    clickTextEl.setText("Close Modal While In File View");
  }
  initCss(contentEl, modalEl, containerEl) {
    contentEl.classList.add("float-search-modal-content");
    modalEl.classList.add("float-search-modal");
    containerEl.classList.add("float-search-modal-container");
  }
  async initSearchView(contentEl) {
    const [createdLeaf, embeddedView] = spawnLeafView(this.plugin, contentEl);
    this.searchLeaf = createdLeaf;
    this.searchEmbeddedView = embeddedView;
    this.searchLeaf.setPinned(true);
    await this.searchLeaf.setViewState({
      type: "search"
    });
    setTimeout(async () => {
      var _a2, _b2, _c2, _d2, _e;
      await this.searchLeaf.view.setState(this.state, true);
      ((_a2 = this.state) == null ? void 0 : _a2.current) ? this.searchLeaf.view.searchComponent.inputEl.setSelectionRange(0, 0) : this.searchLeaf.view.searchComponent.inputEl.setSelectionRange((_c2 = (_b2 = this.state) == null ? void 0 : _b2.query) == null ? void 0 : _c2.length, (_e = (_d2 = this.state) == null ? void 0 : _d2.query) == null ? void 0 : _e.length);
    }, 0);
    return;
  }
  initInput() {
    const inputEl = this.contentEl.getElementsByTagName("input")[0];
    inputEl.focus();
    inputEl.onkeydown = (e) => {
      var _a2, _b2;
      const currentView = this.searchLeaf.view;
      switch (e.key) {
        case "ArrowDown":
          if (e.shiftKey) {
            currentView.onKeyShowMoreAfter(e);
            if (currentView.dom.focusedItem) {
              if (currentView.dom.focusedItem.collapsible) {
                currentView.dom.focusedItem.setCollapse(false);
              }
            }
            break;
          } else {
            currentView.onKeyArrowDownInFocus(e);
            break;
          }
        case "ArrowUp":
          if (e.shiftKey) {
            currentView.onKeyShowMoreBefore(e);
            if (currentView.dom.focusedItem) {
              if (currentView.dom.focusedItem.collapseEl) {
                currentView.dom.focusedItem.setCollapse(true);
              }
            }
            break;
          } else {
            currentView.onKeyArrowUpInFocus(e);
            break;
          }
        case "ArrowLeft":
          currentView.onKeyArrowLeftInFocus(e);
          break;
        case "ArrowRight":
          currentView.onKeyArrowRightInFocus(e);
          break;
        case "Enter":
          currentView.onKeyEnterInFocus(e);
          if (e.altKey && currentView.dom.focusedItem) {
            this.close();
          }
          break;
        case "Tab":
          e.preventDefault();
          if (e.shiftKey) {
            if (this.fileLeaf) {
              (_a2 = this.fileLeaf) == null ? void 0 : _a2.detach();
              this.fileLeaf = void 0;
              (_b2 = this.fileEmbeddedView) == null ? void 0 : _b2.unload();
              this.modalEl.toggleClass("float-search-width", false);
              this.fileEl.detach();
              break;
            }
          }
          if (currentView.dom.focusedItem) {
            const item = currentView.dom.focusedItem;
            const file = item.parent.file instanceof import_obsidian2.TFile ? item.parent.file : item.file;
            item.parent.file instanceof import_obsidian2.TFile ? this.initFileView(file, { match: {
              content: item.content,
              matches: item.matches
            } }) : this.initFileView(file, void 0);
          }
          break;
        case "e":
          if (e.ctrlKey) {
            e.preventDefault();
            if (this.fileLeaf) {
              const estate = this.fileLeaf.getViewState();
              estate.state.mode = estate.state.mode === "preview" ? "source" : "preview";
              this.fileLeaf.setViewState(estate, {
                focus: true
              });
              setTimeout(() => {
                this.searchLeaf.view.searchComponent.inputEl.focus();
              }, 0);
            }
            break;
          }
        case "g":
          if (this.fileLeaf && e.ctrlKey) {
            e.preventDefault();
            app.workspace.setActiveLeaf(this.fileLeaf, {
              focus: true
            });
          }
          break;
        case "C":
          if (e.ctrlKey && e.shiftKey) {
            e.preventDefault();
            const text = currentView.dom.focusedItem.el.innerText;
            navigator.clipboard.writeText(text);
          }
      }
    };
  }
  initContent() {
    const { contentEl } = this;
    contentEl.onclick = (e) => {
      const resultElement = contentEl.getElementsByClassName("search-results-children")[0];
      if (resultElement.children.length < 2) {
        return;
      }
      let targetElement = e.target;
      if (e.altKey || !this.fileLeaf) {
        while (targetElement) {
          if (targetElement.classList.contains("tree-item")) {
            this.close();
            break;
          }
          targetElement = targetElement.parentElement;
        }
        return;
      }
      if (this.fileLeaf) {
        const currentView = this.searchLeaf.view;
        if (this.searchCtnEl.contains(targetElement)) {
          while (targetElement) {
            if (targetElement.classList.contains("tree-item")) {
              break;
            }
            targetElement = targetElement.parentElement;
          }
          if (!targetElement)
            return;
          const fileInnerEl = targetElement == null ? void 0 : targetElement.getElementsByClassName("tree-item-inner")[0];
          const innerText = fileInnerEl.innerText;
          const file = app.metadataCache.getFirstLinkpathDest(innerText, "");
          if (file) {
            const item = currentView.dom.resultDomLookup.get(file);
            currentView.dom.setFocusedItem(item);
            this.initFileView(file, void 0);
            this.searchLeaf.view.searchComponent.inputEl.focus();
          }
        }
        return;
      }
    };
  }
  async initFileView(file, state) {
    var _a2, _b2, _c2;
    if (this.fileLeaf) {
      await this.fileLeaf.openFile(file, {
        active: false,
        eState: state
      });
      if (((_b2 = (_a2 = this.fileState) == null ? void 0 : _a2.match) == null ? void 0 : _b2.matches[0]) === ((_c2 = state.match) == null ? void 0 : _c2.matches[0]) && state && this.fileState) {
        setTimeout(() => {
          if (this.fileLeaf) {
            app.workspace.setActiveLeaf(this.fileLeaf, {
              focus: true
            });
          }
        }, 0);
      } else {
        this.fileState = state;
        setTimeout(() => {
          this.searchLeaf.view.searchComponent.inputEl.focus();
        }, 0);
      }
      return;
    }
    const { contentEl } = this;
    this.fileEl = contentEl.createDiv({ cls: "float-search-modal-file-ctn" });
    this.modalEl.toggleClass("float-search-width", true);
    this.fileEl.onkeydown = (e) => {
      if (e.ctrlKey && e.key === "g") {
        e.preventDefault();
        e.stopPropagation();
        this.searchLeaf.view.searchComponent.inputEl.focus();
      }
      if (e.key === "Tab" && e.ctrlKey) {
        e.preventDefault();
        e.stopPropagation();
        this.searchLeaf.view.searchComponent.inputEl.focus();
      }
    };
    const [createdLeaf, embeddedView] = spawnLeafView(this.plugin, this.fileEl);
    this.fileLeaf = createdLeaf;
    this.fileEmbeddedView = embeddedView;
    this.fileLeaf.setPinned(true);
    await this.fileLeaf.openFile(file, {
      active: false,
      eState: state
    });
    this.fileState = state;
    this.searchLeaf.view.searchComponent.inputEl.focus();
  }
};
