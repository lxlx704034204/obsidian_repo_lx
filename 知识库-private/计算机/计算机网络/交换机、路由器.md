## 交换机和路由器、网关和路由
### 交换机Exchange
https://www.bilibili.com/video/BV1fU4y1t7Ju/     
<font color=#0000FF>交换机</font>(邮递员，关心mac地址 不关心ip地址)。  
<font color=#52C41A>核心功能</font>：把数据包发送到正确的位置，老式的说法也叫集线器。 

Exchange相当于邮递员，根据数据包中的目标mac地址，找到他对应的物理端口(一台交换机有很多个端口 它们都有自己的编号,计算机的**网卡**通过**网线**连接到**交换机的网口**上(交换机端口物理位置)，知道了网卡的mac地址在哪个交换机端口上 就能给它发送数据包。) 所以在交换机中 有一张交换机端口号与mac地址的**mac地址表**，Exchange维护着这张表。  
想要与某个mac地址通信时 只需要来查询一下 这个mac地址在哪个端口上 然后从对应的端口发送出去就可以了。  

每一包数据都会有两个mac地址：源mac地址 目标mac地址  
1.交换机收到一包数据后 首先要把这包数据的源mac 与接收端口进行绑定，维护mac地址表。  
2.然后交换机要根据目标mac查找，从哪个端口把数据包发送出去，
- - if(mac地址表中查询到了关联的端口)  
  - - 则直接从关联端口发出  
- - else           
  - - 则**泛洪**：向除了接收端口之外的所有端口群发。  
  - - 如果目标mac地址在这个网络中，则它一定能收到群发的数据包。

如此运行一段时间之后，通过交换机的mac地址表 就可以找到网络中的所有网卡设备。
由此可见：交换机只会关心数据包中的mac地址，而不会关心ip地址。
mac地址在TCP/IP协议中，处于第二层数据链路层，所以交换机通常也被称为二层设备。  
- 物理层
- 数据链路层 mac层 所以交换机通常被称作 二层设备
- 网络层
- 传输层
- 应用层
 
### 路由器				
**路由器**(van接口 公网, lan接口 内网)：
>**忽略van口** 只用lan口：路由器```==```**交换机**！
**加上van口** 即 **网关**。
路由器的van 公网, lan 内网是2个不同的子网，所有从内网访问互联网属于<font color=#0000FF>跨网络</font>，这时候就需要**路由器**来担任**网关**的角色，这一行为就叫**路由**。
不使用路由器的wan口，路由器就就可以当交换机使用，在网络层工作。 

#### 网关 
>网关负责不同网段、子网的数据通信。

#### 子网划分

与 &
- [ ] 1&x=x
- [ ] 0&x=0

子网掩码255.255.255.0  11111111...11100000000 前24位是1 后8位是0，  
子网掩码是连续的1 连续的0，所以通常也已1的数量表示掩码，eg: 255.255.255.0 = 24;  
ip/掩码=子网数量 eg: 192.168.1.0/24 来表示255个ip。  
  - 扩大ip数量，要把子网掩码调小  调小分母
  - 减少ip数量，要把子网掩码调大  调大分子


所以按位相与的结果是 ip地址的前三个字节不变 最后一个字节是0，即：  
192.168.1.10 & 255.255.255.0 = 192.168.1.0  

**子网划分**：ip & 子网掩码 的结果相同，说明在同一子网。  
如下都在同一子网：      

| ip   | 192.168.1.10  | 192.168.1.x   |
| ---- | ------------- | ------------- |
| 掩码 | 255.255.255.0 | 255.255.255.0 |

**子网的意义**：  
因为tcp/ip协议规定：不同子网之间不可以直接通信！
所以不同子网要通信需要通过**网关**来进行**转发**
**网关**上有两张网卡 分别配置了属于两个子网的ip地址，可以在两个网络之间转发数据包，这样就拥有了一个连接了两个子网的网络！ eg:      

| 子网1          |             网关           | 子网2          |
| -------------- | ------------------------- | -------------- |
| 192.168.1.0/24 | 192.168.1.1   192.168.2.1 | 192.168.2.0/24 |

子网1中的计算机a发送数据包时，计算机a会根据目标ip判断是否跟自己属于同一个子网，  
if(在同一个子网)   
&nbsp&nbsp 网则直接从网卡发出；  
else        
&nbsp&nbsp 则需要把数据包的目标mac地址 改为网关mac,然后发送给网关，  	 
&nbsp&nbsp 网关拿到数据包后，通过**路由关系表(路标)**，查询到这一包数据属于子网2，  
&nbsp&nbsp 网关修改目标mac地址为计算机b的mac地址，  
&nbsp&nbsp 修改源mac为自己的mac，  
&nbsp&nbsp 然后从子网2的网卡发出；  
#### 路由
以上出现了多次根据目标ip判断数据包应该如何发送的**行为**，我们就称之为**路由**。  



数据层：
https://www.bilibili.com/video/BV124411k7uV/ 

![](../../../99-Attachment/Pasted%20image%2020230925113118.png)

网络层：
![](../../../99-Attachment/Pasted%20image%2020230925112917.png)

## 光猫
把光信号 转换为 电信号，光猫也具备**路由**的功能，但为了更好的性能一般都会外接一个**路由器**单独使用。



## SNAT(源地址转换) 和 DNAT(目标地址转换)
家庭网络与因特网。在内网IP相同的不同家庭网络中，如何做到访问公网IP不冲突？这也是应用的范例。
https://www.bilibili.com/video/BV1jQ4y1o7bF/  
在计算机网络中，数据包如何发送 是根据目标IP进行路由的，
如果同一个网络中出现两个相同的IP，则arp表会出现混乱，数据包发送到哪台主机上将变成不确定性的行为。
那怎么解决这个问题：就是让数据包从路由器发出去的时候 变成不同的IP地址不就可以了，
这个技术叫**源地址转换 SNAT**技术.
为了简化模型，我们还是先假设路由器的WAN口 接入IP地址为公网IP 比如221.8.14.91，
网关地址为192.168.1.1
我们的内网计算机地址是192.168.1.10，
我们访问的远端IP为36.152.44.96，  
	内网计算机a &nbsp&nbsp&nbsp&nbsp 网关lan 网关wan &nbsp&nbsp&nbsp&nbsp&nbsp 外网互联网  
	192.168.1.1      192.168.1.1  221.8.14.91     36.152.44.96    
1.计算机a发送一包数据出来到路由器上,在这包数据的网络层

  | xxx | 源ip         | 目标ip       |
  | --- | ------------ | ------------ |
  | xxx | 192.168.1.10 | 36.152.44.96 |

2.路由器拿到这一包数据时 需要执行**源地址转换 SNAT**：把源IP改一下，改成WAN口的公网IP：221.8.14.91发送出去

  | xxx | 源ip        | 目标ip       |
  | --- | ----------- | ------------ |
  | xxx | 221.8.14.91 | 36.152.44.96 |
3.处理完之后服务器需要回复，再把源IP作为目标IP发送回来

  | xxx | 源ip         | 目标ip      |
  | --- | ------------ | ----------- |
  | xxx | 36.152.44.96 | 221.8.14.91 |

4.路由器收到回包执行**反向源地址转换SNAT**，再把目标IP改成192.168.1.10 发送给了家庭中的计算机，至此一次通信完成。

  | xxx | 源ip         | 目标ip       |
  | --- | ------------ | ------------ |
  | xxx | 36.152.44.96 | 192.168.1.10 |

其实现实比如上的基本原理要复杂：
假设家庭中有两台计算机 192.168.1.10  192.168.1.11，它们俩同时访问同一个网站  
内网计算机a,b &nbsp&nbsp&nbsp&nbsp 网关lan &nbsp网关wan &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 外网互联网  
192.168.1.10      192.168.1.1  221.8.14.91     36.152.44.96  
192.168.1.11      192.168.1.1  221.8.14.91     36.152.44.96  
发送了两包数据到路由器上，路由器执行SNAT发送出去，看来没什么问题，但是回来的数据包怎么办？  
因为回来的数据包的目标IP都是221.8.14.91，如何从中区分出来两台计算机的数据包，所以这样看只关注IP地址是不行的，
还需要增加一些确定性的标记，这时就要把关联的属性再往下扩展一层扩展到传输层，我们以最常用的传输层协议TCP协议举例，
TCP协议有两个关键属性，源端口和目标端口，这时候我们的**源地址转换SNAT** 就变成了修改源IP和源端口，
并将修改后的端口号和源IP加源端口形成映射关系,比如主机1和主机2的源端口都是12345,修改后主机1的源端口变为23456，
主机2变为34567，在返回包中根据目标端口号是23456还是34567，区分出来是主机1还是主机2的包，并且在反向SNAT的时候，
把目标端口号改回。  

- tcp协议  源端口 目标端口  
- snat修改 源ip + 源端口  

- 主机1   12345 --> 23456   
- 主机2   12345 --> 34567  

除了TCP协议外，udp协议也是同样的道理 通过IP加端口进行关联，  
- tcp协议  ip地址 + 端口号  
- tcp协议  ip地址 + 端口号   
- ICMP协议 ip地址 + type+code   
- 其他协议  ip地址 + 其他标识    

但是我们常用来检测目标联通性的ping命令使用的是ICMP协议，它没有端口信息，
则需要使用协议中的type+code来代替端口进行关联，其他的协议也都是类似的道理，通过协议特定的标记来进行关联。

明白了**SNAT源地址转换**我们再来看一下**DNAT(目标地址转换)**,顾名思义跟SNAT相反，DNAT是把目标地址修改的技术。  
DNAT作用：  
如果我们的内网计算机对外提供服务，公网上发过来的请求不能直接到达内网计算机，我们就需要路由器用DNAT技术帮于请求，
比如我们内网有一台主机192.168.1.10上有一个web服务监听了80端口，  
1.我们需要在路由器上配置一个DNAT,内容为访问公网地址的8080端口，则帮我们转到计算机1 也就是192.168.1.10的80端口，  
2.则当访问数据包从WAN口进入后 路由器执行DNAT修改目标地址为192.168.1.10 修改目标端口为80,把数据包转发给了计算机1。

内网计算机a,b &nbsp&nbsp&nbsp&nbsp 网关lan &nbsp网关wan &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 外网互联网  
192.168.1.10      192.168.1.1  221.8.14.91     36.152.44.96  
192.168.1.11      192.168.1.1  221.8.14.91     36.152.44.96  

NAT技术深入到我们生活的方方面面，小到家庭网络大到庞大的运营商网络、云计算平台，都通过NAT技术，一层层的将我们的网络进行了分隔。  
在IPV4地址严重匮乏的今天，我们的计算机网络仍旧能正常的运转，多亏了NAT技术的存在。

## TCP协议与UDP协议 # 三次握手与四次挥手
二者都工作在传输层，用于程序之间的数据传输。
- 物理层  
- 数据链路层
- 网络层  
- 传输层  
- 应用层  

### tcp与udp之间的区别

如果把人与人的通信 比喻为进程与进程的通信 我们基本有两种方式  
第一种方式是<font color=#2485E3>写信(udp 基于非连接)</font>，有以下几种无法确认的因素：     
- 信寄出去之后对方是否能收到？  
- 以及收到的信内容是否完整？  
- 先后寄两封信过去是否按照顺序接收？   
- 收信地址和收信人是否存在？   

第二种方式是<font color=#2485E3>打电话(tcp 基于 连接)</font>  
&nbsp&nbsp 从拨打电话到对方接通，互相通话，再到结束通话后挂断，这一系列的流程都能得到及时的反馈，并且能确认对方准确的接收到。

tcp 传输数据稳定可靠 适用于对网络通讯质量要求较高的场景，需要准确无误的传输给对方，比如传输文件发送邮件浏览网页等 

udp 优点是速度快 但是会丢包 适用于对实时性要求较高 但是对少量丢包并没有太大要求的场景 比如域名查询 语音通话视频直播等。  udp还有一个非常重要的应用场景 就是隧道网络，比如vpn、以及在SDN中用到的VXLAN


### tcp
**tcp的过程：**  
三次握手，传输确认，四次挥手，  
![](../../../99-Attachment/Pasted%20image%2020230925184028.png)  
**三次握手**是建立连接的过程，当客户端向服务端发起连接时，会先发一包连接请求数据，过去询问一下‘能否与你建立连接？’这包数据我们称之为SYN包；  
如果对端同意连接，则回复一包SYN+ACK包，客户端收到之后回复一包ACK包，连接建立，这个过程中互相发送了三包数据(三次握手)。  
**为什么要三次握手而不是两次握手?**  
服务端回复完 SYN+ACK之后就建立连接 这是为了防止因为已失效的请求报文 突然又传到服务器引起错误，这是什么意思？  
假设采用两次握手建立连接，客户端向服务端发送了一个SYN包 来请求建立连接 因为某些未知的原因并没有到达服务器 在中间某个网络节点产生了滞留 为了建立连接客户端会重发SYN包 这次的数据包正常送达 服务端回复SYN+ACK 之后建立起了连接 但是第一包数据阻塞的网络节点 突然恢复 第一包SYN包又送达到服务端 这时服务端会误认为是客户端 又发起了一个新的连接 从而在两次握手之后 进入等待数据状态 服务端认为是两个连接 而客户端认为是一个连接 造成了状态不一致  
如果在三次握手的情况下 服务端收不到最后的ACK包 自然不会认为连接建立成功 所以三次握手本质上来说 就是为了解决网络信道不可靠的问题 为了能够在不可靠的信道上 建立起可靠的连接 经过三次握手之后 客户端和服务端都进入了数据传输状态。我们说过，tcp协议需要在不可靠的信道上 保证可靠的连接   
现在就有几个问题需要面对 一包数据有可能会被拆成多包发送 如何处理丢包问题，这些数据包到达的先后顺序不同，如何处理乱序问题 针对这些要求 tcp协议为每一个连接建立了一个发送缓冲区 从建立链接后的第一个字节的序列号为0 后面每个字节的序列号就会增加1  发送数据时 从发送缓冲区取一部分数据组成发送报文 在其tcp协议头中会附带序列号和长度 接受端在收到数据后需要回复确认报文 确认报文中的ACK 等于接收序列号加长度 也就是下一包数据 需要发送的起始序列号 这样一问一答的发送方式 能够使发送端确认发送的数据 已经被对方收到 发送端也可以一次发送 连续的多包数据 接收端只需要回复一次ACK就可以了 这样发送端 可以把待发送的数据分割成一系列的碎片 发送到对段  对端根据序列号和长度 在接收后重构出来完整的数据 假设其中丢失了某些数据包 在接收端可以要求发送端重传 比如丢失了100-199 这100个字节 接收端向发送端发送 ACK=100的报文  发送端收到后重传这一包数据 接收端进行补齐 以上过程不区分客户端和服务端 tcp连接是全双工的 对于两端来说均采用上述机制

**四次挥手**  
处于连接状态的客户端和服务端 都可以发起关闭连接请求 此时需要四次挥手来进行连接关闭  
第1次：假设客户端主动发起连接关闭请求 他需要将服务端发起一包FIN包 表示要关闭连接 自己进入终止等待1状态 
第2次：服务端收到FIN包 发送一包ACK包 表示自己进入了关闭等待状态 客户端进入终止等待2状态
第3次：服务端此时还可以发送未发送的数据 而客户端还可以接收数据 待服务端发送完数据之后 发送一包FIN包 进入最后确认状态
第4次：客户端收到之后回复ACK包 进入超时等待状态 经过超时时间后关闭连接 而服务端收到ACK包后立即关闭连接  
![](../../../99-Attachment/Pasted%20image%2020230925183007.png)  

为什么客户端需要等待超时时间？  
这是为了保证对方已收到ACK包 因为假设客户端发 送完最后一包ACK包后就释放了连接 一旦ACK包在网络中丢失 服务端将一直停留在最后确认状态 如果客户端发送最后一包ACK包后 等待一段时间 这时服务端因为没有收到ACK包 会重发FIN包 客户端会响应这个FIN包 重发ACK包并刷新超时时间 这个机制跟三次握手一样 也是为了保证在不可靠的网络链路中 进行可靠的连接断开 确认

### udp协议
发送数据 就是简单的把数据包封装一下，然后从网卡发出去就可以了 数据包之间并没有状态上的联系 正因为udp这种简单的处理方式 导致他的性能能损耗非常少 对于cpu 内存资源的占用也远小于tcp 但是对于网络传输过程中产生的丢包 udp协议并不能保证。
所以udp在传输稳定性上要弱于tcp 

## IP地址与mac地址 dhcp与arp
- ip地址   建筑物中的主人 收件人  
- mac地址  建筑物物理地址 收件地址  
- 网卡     建筑物  

在计算机网络中发送信息，需要填写**内容**和对方的**ip地址**，操作系统会根据目标ip自动查询arp表 获取对方的mac地址 补齐这封信，从网卡发出去。  

&nbsp我们填写 &nbsp&nbsp 操作系统填写  
目标ip 内容   &nbsp目标MAC    

手机、电脑、电视机等都是由内部的网卡设备所进行的，他们的通信都是由内部的网卡设备所进行的，所以我们可以统一用网卡来表示设备。每张网卡在出厂时都会写入一个全球唯一的MAC地址(6个字节),中间用横杠隔开，
前三个字节表示网络硬件厂商编号，由(IEEE)国际性电子技术 与电子工程师协会分配。
后三个字节表示该制造厂商所制造的网卡的序列号。  
mac地址 表示了网卡在网络中的确定位置，那这个位置是如何表示与确定的呢？  
- 门牌号 = 端口号 绑定 mac地址     

比如我们的计算机a 通过网线接入到了**交换机的端口**1，那这个端口1就是网络中的具体位置，就像我们的**门牌号**一样，
交换机就知道了某个mac地址在端口1上，从而就把mac地址与端口进行了绑定。
我们的网卡接入网络后如果要通信 需要给他配置另一个地址ip地址，
### dhcp静态ip
dhcp自动获取ip，当电脑插上网线或者手机连入到wifi，操作系统网络协议栈会自动向外发送一包dhcp请求，请求为其分配ip地址，路由器获取到dhcp请求后，会为其分配一个ip地址，并通过dhcp回复报文发送回去，操作系统收到了dhcp回包后，将其分配的ip地址配置到网卡上。
注意在一个局域网中，ip地址也是唯一的，路由器不会分配，重复的ip地址给不同的设备。  
当然你也可以把dhcp关掉,手动配置ip，这样你需要手动来配置一个网卡IP地址，但是要保证IP地址的唯一性。  
### arp协议
mac地址是由操作系统来补齐的,那操作系统如何知道对方的mac地址的呢？  
实际上这一步是用arp协议来完成的,   
当计算机a想向计算机b发送消息时,**操作系统**并不会立即发出,他会先发送一包arp广播报文出去，问一下192.168.1.10，的mac地址是多少，此时，网络中的所有设备都收到了这一包请求报文，除了192.168.1.10以外的设备都会丢弃这包请求报文，只有192.168.1.10会回复自己的mac地址是多少，计算机a收到了回复，知道了计算机b的mac地址，他首先会把计算机b的mac地址缓存起来，以便下次使用，然后把这封信补全从网卡发送出去，交换机根据数据包中的目标mac地址找到了计算机b所在的端口，从此端口发送出去，数据就被计算机b收到了。